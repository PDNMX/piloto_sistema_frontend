"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeExceptions = exports.InvalidUriError = void 0;
const json_1 = require("@stoplight/json");
const path_1 = require("@stoplight/path");
class InvalidUriError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.InvalidUriError = InvalidUriError;
const normalize = ($ref, rulesetUri) => {
    const source = json_1.extractSourceFromRef($ref);
    if (typeof source !== 'string') {
        throw new InvalidUriError(buildInvalidUriErrorMessage($ref, rulesetUri, 'Missing source'));
    }
    if (rulesetUri === void 0 && !path_1.isAbsolute(source)) {
        throw new InvalidUriError(buildInvalidUriErrorMessage($ref, rulesetUri, 'Only absolute Uris are allowed when no base ruleset uri has been provided'));
    }
    const pointer = json_1.extractPointerFromRef($ref);
    if (typeof pointer !== 'string') {
        throw new InvalidUriError(buildInvalidUriErrorMessage($ref, rulesetUri, 'Missing pointer fragment'));
    }
    try {
        json_1.pointerToPath(pointer);
    }
    catch (_a) {
        throw new InvalidUriError(buildInvalidUriErrorMessage($ref, rulesetUri));
    }
    const path = rulesetUri === undefined || path_1.isAbsolute(source) ? source : path_1.join(rulesetUri, '..', source);
    return path_1.normalize(path) + pointer;
};
const buildErrorMessagePrefix = ($ref, rulesetUri) => {
    let prefix = '';
    if (rulesetUri !== void 0) {
        prefix += `in ruleset \`${rulesetUri}\`, `;
    }
    return prefix + `\`except\` entry (key \`${$ref}\`) is malformed. `;
};
const buildInvalidUriErrorMessage = ($ref, rulesetUri, precision) => {
    return (buildErrorMessagePrefix($ref, rulesetUri) +
        `Key \`${$ref}\` is not a valid uri${precision ? ` (${precision})` : ''}.`);
};
function mergeExceptions(target, source, baseUri) {
    for (const [location, sourceRules] of Object.entries(source)) {
        const normalizedLocation = normalize(location, baseUri);
        const targetRules = target[normalizedLocation] !== undefined ? target[normalizedLocation] : [];
        const set = new Set(targetRules);
        if (sourceRules.length === 0) {
            throw new Error(buildErrorMessagePrefix(location, baseUri) + 'An empty array of rules has been provided.');
        }
        sourceRules.forEach(r => {
            if (r.length === 0) {
                throw new Error(buildErrorMessagePrefix(location, baseUri) + 'A rule with an empty name has been provided.');
            }
            set.add(r);
        });
        target[normalizedLocation] = [...set].sort((a, b) => a.localeCompare(b));
    }
}
exports.mergeExceptions = mergeExceptions;
//# sourceMappingURL=exceptions.js.map